<!DOCTYPE html>
<html >
	<head>
		<meta charset="UTF-8">
		<title>the unseen</title>
		<link rel="stylesheet" href="css/style.css">
                <script src="js/libs/dat.gui.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js" integrity="sha512-yNJzAsg5JyP91u+sLHlUDULMBd3hmEiVkYeeN1cQBKaLZ7EyT6oH2u5THNIRM2Fu6VKcZJv+F/QAp1h/qzy9Ow==" crossorigin="anonymous"></script>
	</head>
        <script id="vertexShader" type="x-shader/x-fragment">
	  varying vec2 texCoordVarying;
              uniform bool decode;
        uniform vec2 resolution;

	  void main() {
	      texCoordVarying = uv;
	      gl_Position =   projectionMatrix *
		  modelViewMatrix *
		  vec4(position,1.0);
	  }
	</script>
      <script id="fragmentShader" type="x-shader/x-fragment">
        uniform bool decode;
        uniform vec2 resolution;
        varying vec2 texCoordVarying;
        uniform sampler2D tex0;
        uniform float time;

        struct RGB{
            uint r;
            uint g;
            uint b;
        };

        void encode_image(inout RGB dstPixel, RGB srcPixel)
        {
            dstPixel.r = (dstPixel.r & uint(0xF0)) | (srcPixel.r & uint(0xF0)) >> 4;
            dstPixel.g = (dstPixel.g & uint(0xF0)) | (srcPixel.g & uint(0xF0)) >> 4;
            dstPixel.b = (dstPixel.b & uint(0xF0)) | (srcPixel.b & uint(0xF0)) >> 4;
        }


        void decode_image(inout RGB dstPixel)
        {
            dstPixel.r = (dstPixel.r & uint(0x0F)) << 4;
            dstPixel.g = (dstPixel.g & uint(0x0F)) << 4;
            dstPixel.b = (dstPixel.b & uint(0x0F)) << 4;
        }
        /////////////////////////////////////////////////////////

        float rand(const in float n){return fract(sin(n) * 1e4);}
float rand(const in vec2 n) { return fract(1e4 * sin(17.0 * n.x + n.y * 0.1) * (0.1 + abs(sin(n.y * 13.0 + n.x))));
}

float noise(float x) {
    float i = floor(x);
    float f = fract(x);
    float u = f * f * (3.0 - 2.0 * f);
    return mix(rand(i), rand(i + 1.0), u);
}

float noise(vec2 x) {
    vec2 i = floor(x);
    vec2 f = fract(x);

    // Four corners in 2D of a tile
    float a = rand(i);
    float b = rand(i + vec2(1.0, 0.0));
    float c = rand(i + vec2(0.0, 1.0));
    float d = rand(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float noise(vec3 x) {
    const vec3 step = vec3(110, 241, 171);

    vec3 i = floor(x);
    vec3 f = fract(x);

    float n = dot(i, step);

    vec3 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(mix( rand(n + dot(step, vec3(0, 0, 0))), rand(n + dot(step, vec3(1, 0, 0))), u.x),
                   mix( rand(n + dot(step, vec3(0, 1, 0))), rand(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
               mix(mix( rand(n + dot(step, vec3(0, 0, 1))), rand(n + dot(step, vec3(1, 0, 1))), u.x),
                   mix( rand(n + dot(step, vec3(0, 1, 1))), rand(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
}
        ///////////////////////////////////////////////////////////

        vec3 cosPalette(float t){

    vec3 a = vec3(0.5,0.5,0.25);
    vec3 b = vec3(0.5,0.5,0.4);
    vec3 c = vec3(.2,.3,1.);
    vec3 d = vec3(.1,0.3,0.62);
  return a + b*cos( 6.28318*(c*t+d));
}

void pR(inout vec2 p, float a) {
    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
}

        float power = 9.;
float bailout = 2.5;
const int iterations = 10;

float Mandelbulb(vec3 pos)
{  	vec3 z = pos;
	float dr = 1.0;
	float r = 0.0;
	for (int i = 0; i < iterations; i++) {
		r = length(z);
		if (r>bailout) break;

	    //Conversion a coordenadas polares
		float theta = acos(z.z/r);
		float phi = atan(z.y,z.x);
		dr =  pow( r, power-1.0)*power*dr + 1.0;

		//Escalamos y trasladamos
		float zr = pow( r,power);
		theta = theta*power;
		phi = phi*power;

		//Conversion a coordenadas cartesianas
		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z+=pos;
	}
	return 0.6*log(r)*r/dr;
}

        vec3 op_repeat(vec3 p, vec3 c) {
	    return mod(p, c) - 0.5 * c;
        }

        float scene(vec3 pos){
            pR(pos.xy,time*0.0009);
            float manda = Mandelbulb(pos);
            return manda;
        }

        float trace (vec3 rayOrigin, vec3 camOrigin){

            float max_distance = 100.;
            float totalDist = 0.;
            const int max_pasos = 80;

            for (int i = 0; i < max_pasos; i++) {
                vec3 posOnRay = totalDist*rayOrigin + camOrigin;
                float dist = scene(posOnRay);
                totalDist += dist;
                if (dist < 0.001){break;}
                if(totalDist > max_distance){return 0.;}

            }

            return totalDist;
        }


        vec3 estimateNormal(vec3 p) {
            vec2 e = vec2 (0.001, 0.);

            vec3 n = scene(p)- vec3(
                scene(p-e.xyy),
                scene(p-e.yxy),
                scene(p-e.yyx));

            return normalize(n);
        }

        vec3 iluminacion(vec3 posActual, vec3 camaraPos){

            vec3 fuenteDeLuz = vec3(50.,3.,-30.);
            vec3 normal = estimateNormal(posActual);

            vec3 l = normalize(fuenteDeLuz - posActual);
            float dif = clamp(dot(l, normal),0.,1.);
            vec3 colorDif = cosPalette(dif*0.1)*dif;

            // Especular
            vec3 lReflejada =normalize(reflect(-l,normal));
            vec3 camDir = normalize(camaraPos - posActual);
            float specular = pow(clamp(dot(lReflejada, camDir),0.,1.),250.);
            specular = min(specular,dif);
            vec3 colorSpec = vec3(1.)*noise(posActual*20.)*specular;


            //Ambiental
            vec3 colorAmb = vec3(0.,0.,1.) * 0.001;


            vec3 color = colorDif + colorAmb + colorSpec;

            return color;
        }

        vec3 mirarDesde(vec2 uv, vec3 camOrigin, vec3 camTarget){
            //Transformamos nuestro sistema de coordenadas de acuerdo al camTarget
            vec3 zAxis = normalize(camTarget - camOrigin);
            vec3 up = vec3(0,1,0);
            vec3 xAxis = normalize(cross(up, zAxis));
            vec3 yAxis = normalize(cross(zAxis, xAxis));

            float fov = 3.;

            vec3 dir = (normalize(uv.x * xAxis + uv.y * yAxis + zAxis * fov));

            return dir;
        }



        void main()
        {
            vec2 uv = texCoordVarying * vec2(resolution.x/resolution.y, 1.0);

            vec3 img1; vec3 img2;

            img1 = texture2D(tex0, texCoordVarying).xyz;

            ///fractal
            vec3 pos = vec3(uv,1.);
            vec4 color;

            vec3 rayOrigin = normalize(pos);
            vec3 camOrigin = vec3(0.,.4,-1.1);
            vec3 dir = mirarDesde(uv, camOrigin, vec3(0.,1.,1.));

            float t = trace(dir, camOrigin);
            if (t > 0.){
                vec3 posActual = t * dir + camOrigin;

                color.rgb = iluminacion(posActual,camOrigin);

            }
            //Correccion Gamma
            float gamma = .8;
            color.rgb = pow(color.rgb, vec3(1./gamma));


            img2 = color.rgb;


            RGB dstPixel;RGB srcPixel;

            dstPixel.r = uint(img1.r*255.);
            dstPixel.g = uint(img1.g*255.);
            dstPixel.b = uint(img1.b*255.);

            srcPixel.r = uint(img2.r*255.);
            srcPixel.g = uint(img2.g*255.);
            srcPixel.b = uint(img2.b*255.);

            //Encode texture
            encode_image(dstPixel, srcPixel);
            //Decode texture
            if(decode){
                decode_image(dstPixel);
            }

             gl_FragColor = vec4(float(dstPixel.r)/255.,float(dstPixel.g)/255., float(dstPixel.b)/255.,1.0);
        }

      </script>
	<body>
          <canvas id="canvas"></canvas>
	  <script src="js/sceneSubjects/Shader.js"></script>
	  <script src="js/SceneManager.js"></script>
	  <script src="js/main.js"></script>
	</body>
</html>
